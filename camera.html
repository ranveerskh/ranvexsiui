<script>
/* ===== FIXED detection/scan module ===== */
(function(){
  const $ = id => document.getElementById(id);
  const video = $('video');
  const startBtn=$('startBtn'), stopBtn=$('stopBtn'), flipBtn=$('flipBtn'), torchBtn=$('torchBtn'), zoomRange=$('zoom');
  const setStatus = window.__RBSCAN_SET_STATUS__ || function(){};

  // add a visible bubble so you KNOW it fired
  let bubble = document.getElementById('lastCodeBubble');
  if(!bubble){
    bubble = document.createElement('div');
    bubble.id = 'lastCodeBubble';
    Object.assign(bubble.style,{
      position:'fixed', left:'50%', top:'8px', transform:'translateX(-50%)',
      background:'rgba(20,24,54,.95)', color:'#eaf0ff', padding:'8px 12px',
      border:'1px solid #2b3261', borderRadius:'10px', font:'600 14px/1 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif',
      zIndex:9999, opacity:0, transition:'opacity .15s ease'
    });
    bubble.textContent = '—';
    document.body.appendChild(bubble);
  }
  function flashBubble(txt){
    bubble.textContent = 'Scanned: ' + txt;
    bubble.style.opacity = '1';
    clearTimeout(flashBubble._t);
    flashBubble._t = setTimeout(()=>bubble.style.opacity = '0', 1200);
  }
  function beep(){
    try{
      const ctx = new (window.AudioContext||window.webkitAudioContext)();
      const o = ctx.createOscillator(); const g = ctx.createGain();
      o.type='square'; o.frequency.value=880; o.connect(g); g.connect(ctx.destination);
      g.gain.setValueAtTime(0.0001, ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.12);
      o.start(); o.stop(ctx.currentTime+0.14);
    }catch{}
  }

  const S = window.__RBSCAN_STATE__ = window.__RBSCAN_STATE__ || {};
  Object.assign(S,{stream:null, currentDeviceId:null, running:false, detector:null, usingZX:false, _reader:null});

  async function listCameras(){
    const devs = await navigator.mediaDevices.enumerateDevices();
    return devs.filter(d=>d.kind==='videoinput');
  }

  async function startCamera(){
    if(S.stream) stopCamera();
    const tries = [
      [{video:{facingMode:{exact:'environment'}, width:{ideal:1920}, height:{ideal:1080}}, audio:false}, 'env1080'],
      [{video:{facingMode:'environment', width:{ideal:1280}, height:{ideal:720}}, audio:false}, 'env720'],
      [{video:{facingMode:'environment'}, audio:false}, 'envAny'],
      [{video:true, audio:false}, 'any']
    ];
    if(S.currentDeviceId){
      tries.unshift([{video:{deviceId:{exact:S.currentDeviceId}}, audio:false}, 'selected']);
    }
    let lastErr=null;
    for(const [c] of tries){
      try{
        const stream = await navigator.mediaDevices.getUserMedia(c);
        S.stream = stream; video.srcObject = stream; await video.play();
        stopBtn.disabled=false;
        const cams=await listCameras(); flipBtn.disabled=cams.length<2;

        const track=stream.getVideoTracks()[0];
        const caps=track.getCapabilities?.()||{};
        torchBtn.disabled=!('torch' in caps);

        if('zoom' in caps){
          const st=track.getSettings?.()||{};
          zoomRange.min=caps.zoom.min||1; zoomRange.max=caps.zoom.max||6; zoomRange.step=caps.zoom.step||0.1;
          zoomRange.value=st.zoom||1;
          zoomRange.oninput=()=>track.applyConstraints({advanced:[{zoom:Number(zoomRange.value)}]});
        }else{
          zoomRange.disabled=true;
        }

        const st=track.getSettings?.(); if(st?.deviceId) S.currentDeviceId=st.deviceId;
        return;
      }catch(e){ lastErr=e; }
    }
    setStatus('Failed to start camera. Use HTTPS and allow Camera.');
    throw lastErr||new Error('getUserMedia failed');
  }

  function stopCamera(){
    if(S.stream){ S.stream.getTracks().forEach(t=>t.stop()); S.stream=null; }
    video.srcObject=null; stopBtn.disabled=true; flipBtn.disabled=true; torchBtn.disabled=true;
  }

  async function flipCamera(){
    const cams = await listCameras(); if(!cams.length) return;
    const idx = cams.findIndex(c=>c.deviceId===S.currentDeviceId);
    const next = cams[(idx+1)%cams.length]; S.currentDeviceId = next.deviceId;
    await start().catch(()=>{});
  }

  async function toggleTorch(){
    if(!S.stream) return;
    const track=S.stream.getVideoTracks()[0];
    const caps=track.getCapabilities?.()||{}; if(!('torch' in caps)) return;
    const cur=track.getConstraints()?.advanced?.[0]?.torch||false;
    await track.applyConstraints({advanced:[{torch:!cur}]});
    setStatus(!cur?'Torch on':'Torch off');
  }

  // Minimal, reliable detection loop:
  // 1) Try detect(video) directly
  // 2) If empty for a bit, try a 720p canvas snapshot
  let rafId=null, framesSinceHit=0;
  async function nativeLoop(){
    if(!S.detector) return;
    S.running = true; startBtn.disabled = true;
    setStatus('Scanning…');
    const work = document.getElementById('work'); const ctx = work.getContext('2d');
    const loop = async ()=>{
      if(!S.running) return;
      try{
        let codes = await S.detector.detect(video);
        if(!codes || codes.length===0){
          framesSinceHit++;
          // fallback: draw downscaled frame and detect that
          if(video.videoWidth && video.videoHeight){
            const targetH = 720, scale = targetH / video.videoHeight;
            work.width = Math.floor(video.videoWidth * scale);
            work.height = Math.floor(video.videoHeight * scale);
            ctx.drawImage(video, 0, 0, work.width, work.height);
            // thin horizontal ROI for 1D barcodes
            const rh = Math.floor(work.height*0.28), rw = Math.floor(work.width*0.9);
            const rx = Math.floor((work.width-rw)/2), ry = Math.floor((work.height-rh)/2);
            const roi = ctx.getImageData(rx, ry, rw, rh);
            // light contrast boost
            const d=roi.data; for(let i=0;i<d.length;i+=4){
              const y = (d[i]*0.2126 + d[i+1]*0.7152 + d[i+2]*0.0722);
              const yy = Math.min(255, Math.max(0, (y-128)*1.2 + 128));
              d[i]=d[i+1]=d[i+2]=yy;
            }
            ctx.putImageData(roi, rx, ry);
            const bmp = await createImageBitmap(work);
            codes = await S.detector.detect(bmp);
            bmp.close?.();
          }
        }else{
          framesSinceHit = 0;
        }

        if(codes && codes.length){
          for(const c of codes){
            const txt = String(c.rawValue||'').trim();
            if(!txt) continue;
            window.__RBSCAN_BUMP__?.(txt);
            flashBubble(txt);
            beep();
          }
        }
      }catch{}
      rafId = requestAnimationFrame(loop);
    };
    loop();
  }

  function stopNativeLoop(){
    S.running=false; if(rafId) cancelAnimationFrame(rafId), rafId=null; startBtn.disabled=false; setStatus('Stopped.');
  }

  async function startZXing(){
    S.usingZX = true; startBtn.disabled=true; setStatus('Scanning with ZXing…');
    const { BrowserMultiFormatReader } = window.ZXingBrowser || window.ZXing;
    const reader = new BrowserMultiFormatReader();
    S._reader = reader;
    reader.decodeFromVideoDevice(S.currentDeviceId, video, (res)=>{
      const txt = res?.text ?? (res?.getText ? res.getText() : '');
      const value = String(txt||'').trim();
      if(value){
        window.__RBSCAN_BUMP__?.(value);
        flashBubble(value);
        beep();
      }
    });
    stopBtn.disabled = false;
  }

  async function start(){
    await startCamera();
    if('BarcodeDetector' in window){
      try{
        S.detector = new window.BarcodeDetector({
          formats: ['ean_13','ean_8','upc_a','upc_e','code_128','code_39','itf','codabar','qr_code']
        });
      }catch{ S.detector = new window.BarcodeDetector(); }
      await nativeLoop();
    }else{
      await startZXing();
    }
  }

  function stop(){
    if(S.usingZX){
      if(S._reader){ try{ S._reader.reset(); }catch{} S._reader=null; }
      S.usingZX=false; startBtn.disabled=false;
    }
    stopNativeLoop(); stopCamera();
  }

  // Wire buttons
  startBtn.onclick=()=>start().catch(()=>{});
  stopBtn.onclick=()=>stop();
  flipBtn.onclick=()=>flipCamera();
  torchBtn.onclick=()=>toggleTorch();

  // keep video alive when resuming
  document.addEventListener('visibilitychange', ()=>{
    if(document.visibilityState==='visible' && S.stream && video.paused){ video.play().catch(()=>{}); }
  });
})();
</script>